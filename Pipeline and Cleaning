# Load all packages
library(tidyverse)
library(randomForest)
library(caret)
library(Metrics)
library(data.table)
library(ggplot2)
library(googledrive)

# Set up Google Drive authentication
options(gargle_oauth_cache = ".secrets")
drive_auth(cache = ".secrets", email = TRUE)

# ==========================================
# Data combo from drive folder
# ==========================================

combine_navs_csvs <- function(folder_path = "Navs CSVs", use_google_drive = TRUE) {
  
  cat("========================================\n")
  cat("Combining CSVs\n")
  cat("========================================\n\n")
  
  if (use_google_drive) {
    # Find the folder in Google Drive
    cat("Searching for folder:", folder_path, "\n")
    folder <- drive_get(folder_path)
    
    if (nrow(folder) == 0) {
      stop("Folder not found")
    }
    
    # List all CSV files
    cat("Finding CSVs in folder...\n")
    files <- drive_ls(folder, pattern = "\\.csv$")
    
    if (nrow(files) == 0) {
      stop("No CSV files found in the folder")
    }
    
    cat("Found", nrow(files), "CSV files\n\n")
    
    # Create temp directory
    temp_dir <- tempdir()
    
    # Download and combine all CSV files
    all_data_list <- list()
    
    for (i in 1:nrow(files)) {
      cat("Processing file", i, "of", nrow(files), ":", files$name[i], "\n")
      
      # Download file
      temp_file <- file.path(temp_dir, files$name[i])
      
      tryCatch({
        drive_download(files$id[i], path = temp_file, overwrite = TRUE, verbose = FALSE)
        
        # Use fread for reading
        df <- data.table::fread(temp_file, 
                                stringsAsFactors = FALSE,
                                na.strings = c("", "NA", "N/A", "null", "NULL"),
                                fill = TRUE)
        
        # Add source file
        df$SourceFile <- files$name[i]
        
        all_data_list[[i]] <- df
        
        cat("  Loaded", nrow(df), "rows\n")
        
      }, error = function(e) {
        cat("   Error loading file:", e$message, "\n")
      })
      
      # Clean up
      if (file.exists(temp_file)) {
        unlink(temp_file)
      }
    }
    
  } else {
    # Local file processing
    stop("Please use Google Drive")
  }
  
  # Remove NULL entries
  all_data_list <- all_data_list[!sapply(all_data_list, is.null)]
  
  if (length(all_data_list) == 0) {
    stop("No data")
  }
  
  cat("\nCombining", length(all_data_list), "dataframes...\n")
  
  # Combine using rbindlist
  combined_data <- data.table::rbindlist(all_data_list, 
                                         use.names = TRUE, 
                                         fill = TRUE,
                                         idcol = "FileIndex")
  
  combined_data <- as.data.frame(combined_data)
  
  cat("Successfully combined data\n")
  cat("Total rows:", nrow(combined_data), "\n")
  cat("Total columns:", ncol(combined_data), "\n\n")
  
  return(combined_data)
}

# ==========================================
# Data Cleaning 
# ==========================================

clean_all_data <- function(df) {
  
  cat("Cleaning Data \n")

  
  original_rows <- nrow(df)
  
  # Create PitcherId to Pitcher name mapping
  if (all(c("PitcherId", "Pitcher") %in% names(df))) {
    pitcher_mapping <- df %>%
      select(PitcherId, Pitcher) %>%
      distinct() %>%
      filter(!is.na(Pitcher), !is.na(PitcherId))
    
    cat("Created pitcher ID to name mapping:\n")
    cat(sprintf("  • Found %d unique pitcher IDs with names\n", nrow(pitcher_mapping)))
    
    # Save mapping as attribute
    attr(df, "pitcher_mapping") <- pitcher_mapping
  }
  
  # Step 1: Update PitchCall based on PlayResult for InPlay events
  if (all(c("PitchCall", "PlayResult") %in% names(df))) {
    cat("\nStep 1: Updating PitchCall for InPlay events:\n")
    
    # Count InPlay events before update
    inplay_count <- sum(df$PitchCall == "InPlay", na.rm = TRUE)
    cat(sprintf("  • Total InPlay events: %d\n", inplay_count))
    
     First standardize PlayResult before using it to update PitchCall
    # Count variations before standardization
    homerun_count <- sum(df$PlayResult == "Homerun", na.rm = TRUE)
    sinigle_count <- sum(df$PlayResult == "Sinigle", na.rm = TRUE)
    
    # Standardize PlayResult variations
    df <- df %>%
      mutate(
        PlayResult = case_when(
          PlayResult == "Homerun" ~ "HomeRun",  # Standardize to HomeRun
          PlayResult == "Sinigle" ~ "Single",   # Fix typo
          TRUE ~ PlayResult
        )
      )
    
    if (homerun_count > 0) {
      cat(sprintf("  • Standardized 'Homerun' → 'HomeRun': %d entries\n", homerun_count))
    }
    if (sinigle_count > 0) {
      cat(sprintf("  • Fixed 'Sinigle' → 'Single': %d entries\n", sinigle_count))
    }
    
    # For each InPlay, update PitchCall to the actual result from PlayResult
    inplay_indices <- which(df$PitchCall == "InPlay")
    
    if (length(inplay_indices) > 0) {
      # Track updates
      updates <- table(df$PlayResult[inplay_indices])
      cat("  • Updating InPlay PitchCalls to:\n")
      for (result in names(updates)) {
        if (!is.na(result) && result != "") {
          cat(sprintf("    - %s: %d\n", result, updates[result]))
        }
      }
      
      # Update PitchCall to match PlayResult when PitchCall was InPlay
      df$PitchCall[inplay_indices] <- df$PlayResult[inplay_indices]
      
      # Handle any NA or empty PlayResults for InPlay
      na_inplay <- inplay_indices[is.na(df$PitchCall[inplay_indices]) | df$PitchCall[inplay_indices] == ""]
      if (length(na_inplay) > 0) {
        df$PitchCall[na_inplay] <- "InPlay"
        cat(sprintf("    - Kept as InPlay (no PlayResult): %d\n", length(na_inplay)))
      }
    }
  }
  
  # Pitch CallCleaning
  if ("PitchCall" %in% names(df)) {
    cat("\nStep 2: Cleaning PitchCall column (with BallInDirt fix and HomeRun standardization):\n")
    
    # Get initial counts of all ball-related calls
    cat("  Initial counts:\n")
    ball_called <- sum(df$PitchCall == "BallCalled", na.rm = TRUE)
    ball_intentional <- sum(df$PitchCall == "BallIntentional", na.rm = TRUE)
    ball_in_dirt <- sum(df$PitchCall == "BallInDirt", na.rm = TRUE)
    
    cat(sprintf("    - BallCalled: %d\n", ball_called))
    cat(sprintf("    - BallIntentional: %d\n", ball_intentional))
    cat(sprintf("    - BallInDirt: %d\n", ball_in_dirt))
    
    # Also count variations that need standardization
    homerun_pitchcall <- sum(df$PitchCall == "Homerun", na.rm = TRUE)
    sinigle_pitchcall <- sum(df$PitchCall == "Sinigle", na.rm = TRUE)
    
    # Also count foul variations
    foul_ball <- sum(df$PitchCall == "FoulBall", na.rm = TRUE)
    foul_not_fieldable <- sum(df$PitchCall == "FoulBallNotFieldable", na.rm = TRUE)
    foul_fieldable <- sum(df$PitchCall == "FoulBallFieldable", na.rm = TRUE)
    
    # CRITICAL: Use mutate with case_when for robust conversion
    df <- df %>%
      mutate(
        PitchCall = case_when(
          # Ball conversions
          PitchCall == "BallIntentional" ~ "BallCalled",
          PitchCall == "BallInDirt" ~ "BallCalled",
          PitchCall == "BallinDirt" ~ "BallCalled",  # Handle potential case variations
          PitchCall == "Ball In Dirt" ~ "BallCalled",  # Handle potential spacing variations
          
          # Foul conversions
          PitchCall == "FoulBallNotFieldable" ~ "FoulBall",
          PitchCall == "FoulBallFieldable" ~ "FoulBall",
          
          # Standardize HomeRun and fix Sinigle
          PitchCall == "Homerun" ~ "HomeRun",
          PitchCall == "Sinigle" ~ "Single",
          
          # Keep everything else as is
          TRUE ~ PitchCall
        )
      )
    
    # Verify conversions
    cat("\n  After conversion:\n")
    new_ball_called <- sum(df$PitchCall == "BallCalled", na.rm = TRUE)
    remaining_ball_in_dirt <- sum(df$PitchCall == "BallInDirt", na.rm = TRUE)
    remaining_ball_intentional <- sum(df$PitchCall == "BallIntentional", na.rm = TRUE)
    new_foul_ball <- sum(df$PitchCall == "FoulBall", na.rm = TRUE)
    
    cat(sprintf("    - BallCalled: %d (increased by %d)\n", 
                new_ball_called, new_ball_called - ball_called))
    cat(sprintf("    - BallIntentional remaining: %d\n", remaining_ball_intentional))
    cat(sprintf("    - BallInDirt remaining: %d\n", remaining_ball_in_dirt))
    cat(sprintf("    - FoulBall: %d (increased by %d)\n", 
                new_foul_ball, new_foul_ball - foul_ball))
    
    if (homerun_pitchcall > 0) {
      cat(sprintf("    - Standardized 'Homerun' → 'HomeRun': %d entries\n", homerun_pitchcall))
    }
    if (sinigle_pitchcall > 0) {
      cat(sprintf("    - Fixed 'Sinigle' → 'Single': %d entries\n", sinigle_pitchcall))
    }
    
    # Final verification
    if (remaining_ball_in_dirt > 0) {
      cat(sprintf("\n   WARNING: %d BallInDirt entries still remain!\n", remaining_ball_in_dirt))
      # Force conversion of any remaining
      df$PitchCall[df$PitchCall == "BallInDirt"] <- "BallCalled"
      cat("    → Forcing conversion of remaining BallInDirt entries\n")
      
      # Final check
      final_ball_in_dirt <- sum(df$PitchCall == "BallInDirt", na.rm = TRUE)
      if (final_ball_in_dirt == 0) {
        cat("    All BallInDirt entries successfully converted\n")
      }
    } else {
      cat("  All BallInDirt entries successfully converted\n")
    }
    
    if (remaining_ball_intentional > 0) {
      cat(sprintf(" BallIntentional entries still remain!\n", remaining_ball_intentional))
    } else {
      cat("   All BallIntentional entries successfully converted\n")
    }
  }
  
  # Step 3: Clean PlayResult column
  if ("PlayResult" %in% names(df)) {
    cat("\nStep 3: Cleaning PlayResult column:\n")
    
    # Count before changes
    stolen_base_count <- sum(df$PlayResult == "StolenBase", na.rm = TRUE)
    caught_stealing_count <- sum(df$PlayResult == "CaughtStealing", na.rm = TRUE)
    # Note: Sinigle already handled above, but check again
    remaining_sinigle <- sum(df$PlayResult == "Sinigle", na.rm = TRUE)
    remaining_homerun_lower <- sum(df$PlayResult == "Homerun", na.rm = TRUE)
    
    # Use mutate with case_when for consistency
    df <- df %>%
      mutate(
        PlayResult = case_when(
          PlayResult == "StolenBase" ~ "Undefined",
          PlayResult == "CaughtStealing" ~ "Undefined",
          PlayResult == "Sinigle" ~ "Single",  # Double-check
          PlayResult == "Homerun" ~ "HomeRun",  # Double-check
          TRUE ~ PlayResult
        )
      )
    
    cat(sprintf("  • StolenBase entries: %d → converted to 'Undefined'\n", stolen_base_count))
    cat(sprintf("  • CaughtStealing entries: %d → converted to 'Undefined'\n", caught_stealing_count))
    if (remaining_sinigle > 0) {
      cat(sprintf("  • Additional 'Sinigle' → 'Single' fixes: %d entries\n", remaining_sinigle))
    }
    if (remaining_homerun_lower > 0) {
      cat(sprintf("  • Additional 'Homerun' → 'HomeRun' standardization: %d entries\n", remaining_homerun_lower))
    }
  }
  
  # Step 4: Clean and consolidate pitch types
  if (all(c("TaggedPitchType", "AutoPitchType") %in% names(df))) {
    cat("\nStep 4: Cleaning pitch types:\n")
    
    # Count "Other" pitches before removal
    other_count <- sum(df$TaggedPitchType == "Other", na.rm = TRUE)
    if (other_count > 0) {
      cat(sprintf("  • Removing %d 'Other' pitch type entries\n", other_count))
      df <- df %>% filter(TaggedPitchType != "Other")
    }
    
    # Count undefined/NA before replacement
    undefined_count <- sum(df$TaggedPitchType == "Undefined" | 
                             is.na(df$TaggedPitchType) | 
                             df$TaggedPitchType == "", 
                           na.rm = TRUE)
    
    cat(sprintf("  • Undefined/NA pitch types: %d → using AutoPitchType\n", undefined_count))
    
    # Store original for reference
    df$TaggedPitchType_Original <- df$TaggedPitchType
    
    # Replace undefined with AutoPitchType and consolidate pitch types
    df <- df %>%
      mutate(
        TaggedPitchType = case_when(
          # Handle undefined/NA
          TaggedPitchType == "Undefined" ~ AutoPitchType,
          is.na(TaggedPitchType) ~ AutoPitchType,
          TaggedPitchType == "" ~ AutoPitchType,
          
          # Consolidate pitch types
          TaggedPitchType == "TwoSeamFastBall" ~ "Sinker",
          TaggedPitchType == "FourSeamFastBall" ~ "Fastball",
          TaggedPitchType == "Four-Seam" ~ "Fastball",
          TaggedPitchType == "ChangeUp" ~ "Changeup",
          
          # Keep everything else
          TRUE ~ TaggedPitchType
        )
      )
    
    # Remove any "Other" that came from AutoPitchType
    other_from_auto <- sum(df$TaggedPitchType == "Other", na.rm = TRUE)
    if (other_from_auto > 0) {
      cat(sprintf("  • Removing %d 'Other' entries from AutoPitchType\n", other_from_auto))
      df <- df %>% filter(TaggedPitchType != "Other")
    }
    
    # Report consolidations
    cat("   Pitch type consolidations applied:\n")
    cat("    - TwoSeamFastBall → Sinker\n")
    cat("    - FourSeamFastBall & Four-Seam → Fastball\n")
    cat("    - ChangeUp → Changeup\n")
  }
  
  # Step 5: Filter slow fastballs
  if (all(c("TaggedPitchType", "RelSpeed") %in% names(df))) {
    cat("\nStep 5: Filtering velocity outliers:\n")
    
    # Count fastballs below 77 mph
    slow_fastballs <- df %>%
      filter(TaggedPitchType == "Fastball" & RelSpeed < 77) %>%
      nrow()
    
    if (slow_fastballs > 0) {
      cat(sprintf("  • Removing %d fastballs with RelSpeed < 77 mph\n", slow_fastballs))
      
      # Remove slow fastballs
      df <- df %>%
        filter(!(TaggedPitchType == "Fastball" & RelSpeed < 77))
      
      cat(sprintf("  • Rows after removal: %d\n", nrow(df)))
    } else {
      cat("  • No fastballs below 77 mph found\n")
    }
  }
  
  # Final verification of critical conversions
  cat("\n========================================\n")
  cat("FINAL VERIFICATION:\n")
  
  if ("PitchCall" %in% names(df)) {
    problematic_calls <- df %>%
      filter(PitchCall %in% c("BallInDirt", "BallIntentional", 
                              "FoulBallFieldable", "FoulBallNotFieldable",
                              "Homerun", "Sinigle")) %>%  
      count(PitchCall)
    
    if (nrow(problematic_calls) > 0) {
      cat(" Unconverted PitchCall values found:\n")
      print(problematic_calls)
    } else {
      cat("All PitchCall values properly converted\n")
    }
  }
  
  if ("PlayResult" %in% names(df)) {
    problematic_results <- df %>%
      filter(PlayResult %in% c("Homerun", "Sinigle")) %>%  
      count(PlayResult)
    
    if (nrow(problematic_results) > 0) {
      cat("Unconverted PlayResult values found:\n")
      print(problematic_results)
    } else {
      cat("All PlayResult values properly standardized\n")
    }
  }
  
  if ("TaggedPitchType" %in% names(df)) {
    problematic_types <- df %>%
      filter(TaggedPitchType %in% c("Other", "TwoSeamFastBall", 
                                    "FourSeamFastBall", "Four-Seam", "ChangeUp")) %>%
      count(TaggedPitchType)
    
    if (nrow(problematic_types) > 0) {
      cat("⚠ WARNING: Unconverted pitch types found:\n")
      print(problematic_types)
    } else {
      cat("✓ All pitch types properly consolidated\n")
    }
  }
  
  cat("\n✓ Data cleaning complete\n")
  cat(sprintf("  Final row count: %d (removed %d rows)\n", nrow(df), original_rows - nrow(df)))
  
  return(df)
}

# ==========================================
# Continue Filtering
# ==========================================

filter_core_metrics <- function(df) {
  
  cat("\n========================================\n")
  cat("Filtering for velo, spin, IVB, and HB\n")
  cat("========================================\n\n")
  
  original_rows <- nrow(df)
  
  # Core required columns 
  core_required <- c("RelSpeed", "SpinRate", "InducedVertBreak", "HorzBreak")
  
  # Check if columns exist
  missing_cols <- setdiff(core_required, names(df))
  if (length(missing_cols) > 0) {
    stop("Missing required columns: ", paste(missing_cols, collapse = ", "))
  }
  
  # Show missing data in core columns
  cat("Missing values in core columns:\n")
  for (col in core_required) {
    na_count <- sum(is.na(df[[col]]))
    cat(sprintf("  %-20s: %6d (%.2f%%)\n", 
                col, na_count, na_count/original_rows*100))
  }
  
  # Filter for rows with complete Velo/Spin/break metrics only
  cat("\nFiltering for rows with complete core metrics...\n")
  
  df_filtered <- df %>%
    filter(!is.na(RelSpeed),
           !is.na(SpinRate),
           !is.na(InducedVertBreak),
           !is.na(HorzBreak))
  
  rows_removed <- original_rows - nrow(df_filtered)
  
  cat("\n----------------------------------------\n")
  cat("FILTERING RESULTS:\n")
  cat(sprintf("  Original rows:      %8d\n", original_rows))
  cat(sprintf("  Rows removed:       %8d (%.2f%%)\n", 
              rows_removed, rows_removed/original_rows*100))
  cat(sprintf("  Rows retained:      %8d (%.2f%%)\n", 
              nrow(df_filtered), nrow(df_filtered)/original_rows*100))
  cat(sprintf("  Columns unchanged:  %8d\n", ncol(df_filtered)))
  
  cat("\nFiltering complete - kept all columns, filtered rows\n")
  
  return(df_filtered)
}

# Data quality assessment


assess_final_quality <- function(df) {
  
  
  # Basic info
  cat("Dataset Overview:\n")
  cat(sprintf("  Total rows:         %8d\n", nrow(df)))
  cat(sprintf("  Total columns:      %8d\n", ncol(df)))
  
  if ("PitcherId" %in% names(df)) {
    cat(sprintf("  Unique pitchers:    %8d\n", n_distinct(df$PitcherId)))
  }
  
  if ("GameID" %in% names(df)) {
    cat(sprintf("  Unique games:       %8d\n", n_distinct(df$GameID)))
  }
  
  # Core metrics completeness
  cat("\nCore Metrics Status (should be 100% complete):\n")
  core_metrics <- c("RelSpeed", "SpinRate", "InducedVertBreak", "HorzBreak")
  for (metric in core_metrics) {
    if (metric %in% names(df)) {
      complete_pct = sum(!is.na(df[[metric]])) / nrow(df) * 100
      cat(sprintf("  %-20s: %.1f%% complete\n", metric, complete_pct))
    }
  }
  
  # Other columns may have missing data
  cat("\nOther Column Completeness (sample):\n")
  other_cols <- c("PlateLocHeight", "PlateLocSide", "Extension", "RelHeight", "RelSide")
  for (col in other_cols) {
    if (col %in% names(df)) {
      complete_pct = sum(!is.na(df[[col]])) / nrow(df) * 100
      cat(sprintf("  %-20s: %.1f%% complete\n", col, complete_pct))
    }
  }
  
  # CRITICAL: Verify BallInDirt conversion and HomeRun/Single standardization
  
  if ("PitchCall" %in% names(df)) {
    # Check for any remaining non-standard values
    ball_in_dirt_count <- sum(df$PitchCall == "BallInDirt", na.rm = TRUE)
    ball_called_count <- sum(df$PitchCall == "BallCalled", na.rm = TRUE)
    homerun_lower_count <- sum(df$PitchCall == "Homerun", na.rm = TRUE)
    homerun_proper_count <- sum(df$PitchCall == "HomeRun", na.rm = TRUE)
    sinigle_count <- sum(df$PitchCall == "Sinigle", na.rm = TRUE)
    single_count <- sum(df$PitchCall == "Single", na.rm = TRUE)
    
   
    
    # Show full PitchCall distribution
    cat("\nComplete PitchCall Distribution:\n")
    pitch_call_dist <- df %>%
      count(PitchCall) %>%
      arrange(desc(n))
    
    for (i in 1:min(nrow(pitch_call_dist), 15)) {
      cat(sprintf("  %-20s: %6d (%.1f%%)\n", 
                  pitch_call_dist$PitchCall[i],
                  pitch_call_dist$n[i],
                  pitch_call_dist$n[i]/nrow(df)*100))
    }
  }
  
  # Pitch type distribution
  if ("TaggedPitchType" %in% names(df)) {
    cat("\nPitch Type Distribution:\n")
    pitch_dist <- df %>%
      count(TaggedPitchType) %>%
      arrange(desc(n))
    
    for (i in 1:min(nrow(pitch_dist), 10)) {
      cat(sprintf("  %-15s: %6d (%.1f%%)\n", 
                  pitch_dist$TaggedPitchType[i],
                  pitch_dist$n[i],
                  pitch_dist$n[i]/nrow(df)*100))
    }
    
    # Check forx pitch types
    problematic_types <- c("Other", "TwoSeamFastBall", "FourSeamFastBall", "Four-Seam", "ChangeUp")
    found_problematic <- intersect(problematic_types, df$TaggedPitchType)
    if (length(found_problematic) > 0) {
      cat("\n⚠ WARNING: Problematic pitch types still present:\n")
      cat("  ", paste(found_problematic, collapse = ", "), "\n")
    }
  }
  
  # Velo check for fastballs
  if (all(c("TaggedPitchType", "RelSpeed") %in% names(df))) {
    fastball_velos <- df %>%
      filter(TaggedPitchType == "Fastball") %>%
      pull(RelSpeed)
    
    if (length(fastball_velos) > 0) {
      cat("\nFastball velocity check:\n")
      cat(sprintf("  Min velocity:  %.1f mph\n", min(fastball_velos)))
      cat(sprintf("  Mean velocity: %.1f ± %.1f mph\n", 
                  mean(fastball_velos), sd(fastball_velos)))
      cat(sprintf("  Max velocity:  %.1f mph\n", max(fastball_velos)))
    }
  }
  
  return(TRUE)
}

# ==========================================
# Main Pipeline 
# ==========================================

run_necbl_pipeline <- function(folder_path = "Navs CSVs", 
                               save_to_file = TRUE) {
  
  #Pipeline
  
  # Step 1: Combine data
  cat("STEP 1: Combining all CSV files\n")
  cat("========================================\n")
  combined_data <- combine_navs_csvs(folder_path, use_google_drive = TRUE)
  initial_rows <- nrow(combined_data)
  initial_cols <- ncol(combined_data)
  
  # Step 2: Clean all data with enhanced BallInDirt handling
  cat("\nSTEP 2: Comprehensive data cleaning")
  combined_data <- clean_all_data(combined_data)
  
  # Step 3: Filter for core metrics
  cat("\nSTEP 3: Filter for complete core metrics")
  combined_data <- filter_core_metrics(combined_data)
  
  # Step 4: Final quality assessment
  cat("\nSTEP 4: Final quality assessment")
  assess_final_quality(combined_data)
  
  # Step 5: Save results
  if (save_to_file) {
    cat("\n========================================\n")
    cat("SAVING RESULTS\n")
    cat("========================================\n\n")
    
    # Save main data files
    csv_file <- paste0("necbl_clean_", Sys.Date(), ".csv")
    rds_file <- paste0("necbl_clean_", Sys.Date(), ".rds")
    
    write.csv(combined_data, csv_file, row.names = FALSE)
    saveRDS(combined_data, rds_file, compress = TRUE)
    
    cat("✓ Files saved in working directory:\n")
    cat("  •", csv_file, "\n")
    cat("  •", rds_file, "\n")
    
    # File sizes
    cat("\nFile sizes:\n")
    cat(sprintf("  CSV: %.2f MB\n", file.size(csv_file)/(1024^2)))
    cat(sprintf("  RDS: %.2f MB\n", file.size(rds_file)/(1024^2)))
    
    # Save pitcher mapping if it exists
    pitcher_mapping <- attr(combined_data, "pitcher_mapping")
    if (!is.null(pitcher_mapping)) {
      mapping_file <- paste0("pitcher_id_mapping_", Sys.Date(), ".csv")
      write.csv(pitcher_mapping, mapping_file, row.names = FALSE)
      cat("  •", mapping_file, "(pitcher ID to name mapping)\n")
    }
  }
  
  cat("TRANSFORMATION SUMMARY:\n")
  cat("----------------------------------------\n")
  cat(sprintf("  Initial:   %d rows × %d columns\n", initial_rows, initial_cols))
  cat(sprintf("  Final:     %d rows × %d columns\n", nrow(combined_data), ncol(combined_data)))
  cat(sprintf("  Retention: %.1f%% of rows\n", nrow(combined_data)/initial_rows*100))
  
  
  # Final checks for the specific issues
  if ("PitchCall" %in% names(combined_data)) {
    final_ballindirt <- sum(combined_data$PitchCall == "BallInDirt", na.rm = TRUE)
    final_homerun_lower <- sum(combined_data$PitchCall == "Homerun", na.rm = TRUE)
    final_sinigle <- sum(combined_data$PitchCall == "Sinigle", na.rm = TRUE)
    
    if (final_ballindirt == 0 && final_homerun_lower == 0 && final_sinigle == 0) {
      cat("\nVERIFIED: All data standardization complete ✓\n")
    } else {
      
      if (final_ballindirt > 0) cat(sprintf("  - %d BallInDirt entries remain\n", final_ballindirt))
      if (final_homerun_lower > 0) cat(sprintf("  - %d 'Homerun' entries remain\n", final_homerun_lower))
      if (final_sinigle > 0) cat(sprintf("  - %d 'Sinigle' entries remain\n", final_sinigle))
    }
  }
  

  # Store in global environment
  necbl_clean_data <<- combined_data
  cat("Data stored as 'necbl_clean_data' in workspace\n\n")
  
  return(combined_data)
}

# ==========================================
# execute pipeline
# ==========================================

# Run the enhanced pipeline
necbl_data <- run_necbl_pipeline(
  folder_path = "Navs CSVs",
  save_to_file = TRUE
)

# Data is now available as:
# - necbl_data (returned from function)
# - necbl_clean_data (in global environment)
# - necbl_clean_[date].csv and .rds files in working directory
# - pitcher_id_mapping_[date].csv (pitcher ID to name mapping)
